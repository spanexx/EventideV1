import { Injectable, Logger } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { Availability, AvailabilityDocument, AvailabilityType, AvailabilityStatus } from '../availability.schema';
import { Booking, BookingDocument } from '../../booking/booking.schema';
import { CachingService } from '../../../core/cache/caching.service';
import { IAvailabilityBase, IAvailabilityDocument } from '../interfaces/availability.interface';

type AvailabilityLean = Omit<AvailabilityDocument, keyof Document> & { _id: Types.ObjectId };
type AvailabilityData = Omit<IAvailabilityBase, 'id'> & { _id: Types.ObjectId };

@Injectable()
export class AvailabilityCacheService {
  private readonly logger = new Logger(AvailabilityCacheService.name);

  constructor(
    @InjectModel(Availability.name)
    private readonly availabilityModel: Model<AvailabilityDocument>,
    @InjectModel(Booking.name)
    private readonly bookingModel: Model<BookingDocument>,
    private readonly cacheService: CachingService,
  ) {}

  /**
   * Get cached availability or fetch from database
   */
  async getCachedAvailability(
    providerId: string,
    startDate?: Date,
    endDate?: Date,
    includeTemplates: boolean = false,
  ): Promise<IAvailabilityBase[]> {
    // If no date range provided, return all slots
    if (!startDate || !endDate) {
      return await this.availabilityModel.find({ providerId });
    }

    const start = new Date(startDate);
    start.setHours(0, 0, 0, 0);
    const end = new Date(endDate);
    end.setHours(23, 59, 59, 999);

    const cacheKey = `availability:${providerId}:${start.toISOString()}:${end.toISOString()}`;

    try {
      // Try to get the result from the cache first
      const cachedAvailabilities = await this.cacheService.get<IAvailabilityBase[]>(cacheKey);
      if (cachedAvailabilities) {
        this.logger.debug(`Cache HIT for key: ${cacheKey}`);
        return cachedAvailabilities;
      }

      this.logger.debug(`Cache MISS for key: ${cacheKey}. Fetching from DB.`);

      // Get one-off slots for the date range
      const oneOffSlots = await this.availabilityModel.find({
        providerId,
        type: AvailabilityType.ONE_OFF,
        date: { $gte: start, $lte: end },
        status: { $ne: 'cancelled' }
      }).lean<AvailabilityData[]>();

      // Get recurring slots for the date range
      const recurringSlots = await this.availabilityModel.find({
        providerId,
        type: AvailabilityType.RECURRING,
        date: { $gte: start, $lte: end },
        status: { $ne: 'cancelled' }
      }).lean<AvailabilityData[]>();

      const bookedSlots = await this.getBookedSlots(providerId, start, end);

      // Get current time for filtering past slots
      const now = new Date();
      
      // Filter one-off slots that aren't in the past and convert to IAvailability
      const availableOneOffSlots = oneOffSlots
        .filter(slot => {
          const slotStartTime = new Date(slot.startTime);
          return slotStartTime > now; // Only exclude past slots, keep booked slots visible
        })
        .map(slot => ({
          id: slot._id.toString(),
          providerId: slot.providerId,
          type: slot.type,
          dayOfWeek: slot.dayOfWeek,
          date: slot.date,
          startTime: slot.startTime,
          endTime: slot.endTime,
          duration: slot.duration,
          isBooked: slot.isBooked,
          maxBookings: slot.maxBookings,
          status: slot.status as AvailabilityStatus,
          isTemplate: false,
          isInstantiated: false,
          createdAt: slot.createdAt,
          updatedAt: slot.updatedAt
        }));

      // Create a map of existing one-off slots by date+time to prevent duplicates
      // Include BOTH available and booked slots to prevent conflicts
      const oneOffSlotMap = new Map<string, boolean>();
      
      // Add available slots
      availableOneOffSlots.forEach(slot => {
        const key = `${new Date(slot.startTime).toISOString()}_${slot.duration}`;
        oneOffSlotMap.set(key, true);
      });
      
      // Also add booked one-off slots to prevent recurring instances at same time
      oneOffSlots.forEach(slot => {
        if (slot.isBooked || bookedSlots[slot._id.toString()]) {
          const key = `${new Date(slot.startTime).toISOString()}_${slot.duration}`;
          oneOffSlotMap.set(key, true);
        }
      });

      // Filter recurring slots that aren't in the past
      const availableRecurringSlots = recurringSlots
        .filter(slot => {
          const slotStartTime = new Date(slot.startTime);
          return slotStartTime > now;
        })
        .map(slot => ({
          id: slot._id.toString(),
          providerId: slot.providerId,
          type: slot.type,
          dayOfWeek: slot.dayOfWeek,
          date: slot.date,
          startTime: slot.startTime,
          endTime: slot.endTime,
          duration: slot.duration,
          isBooked: slot.isBooked,
          maxBookings: slot.maxBookings,
          status: slot.status as AvailabilityStatus,
          weekOf: slot.weekOf,
          createdAt: slot.createdAt,
          updatedAt: slot.updatedAt
        }));

      // Combine and sort all slots (including booked ones)
      const availableSlots: IAvailabilityBase[] = [...availableOneOffSlots, ...availableRecurringSlots].sort(
        (a, b) => new Date(a.startTime).getTime() - new Date(b.startTime).getTime()
      );

      // Cache the result
      await this.cacheService.set(cacheKey, availableSlots, 5 * 60); // Cache for 5 minutes

      return availableSlots;
    } catch (error) {
      this.logger.error(
        `Failed to retrieve cached availability: ${error.message}`,
        error.stack,
      );
      throw error;
    }
  }

  /**
   * Filter availability by date range, handling both recurring and one-off slots
   */
  private filterAvailabilityByDateRange(
    slots: IAvailabilityBase[],
    startDate: Date,
    endDate: Date,
    bookedSlots: { [key: string]: boolean },
  ): IAvailabilityBase[] {
    const start = new Date(startDate);
    start.setHours(0, 0, 0, 0);
    
    const end = new Date(endDate);
    end.setHours(23, 59, 59, 999);

    this.logger.debug(`Filtering availability from ${start.toISOString()} to ${end.toISOString()}`);

    const filteredSlots: IAvailabilityBase[] = [];

    for (const slot of slots) {
      // Handle ONE-OFF slots
      if (slot.type === AvailabilityType.ONE_OFF && slot.date) {
        const slotDate = new Date(slot.date);
        slotDate.setHours(0, 0, 0, 0);
        
        if (slotDate >= start && slotDate <= end) {
          // Enhanced debug logging
          this.logger.debug(`ONE-OFF slot ${slot.id} details:
            - isBooked: ${slot.isBooked}
            - bookedSlots: ${JSON.stringify(bookedSlots)}
            - slotDate: ${slotDate.toISOString()}
            - start: ${start.toISOString()}
            - end: ${end.toISOString()}`
          );
          
          // Exclude if booked
          if (!slot.isBooked && slot.id && !bookedSlots[slot.id]) {
            filteredSlots.push(slot);
            this.logger.debug(`Including ONE-OFF slot: ${slot.id} on ${slotDate.toISOString()}`);
          } else {
            this.logger.debug(`Excluding ONE-OFF slot ${slot.id} due to booking status`);
          }
        }
      }
      
      // Handle RECURRING slots - generate instances for matching days
      else if (slot.type === AvailabilityType.RECURRING && slot.dayOfWeek !== undefined) {
        const slotData: AvailabilityData = {
          ...slot,
          _id: new Types.ObjectId(slot.id)
        };
        const instances = this.generateRecurringInstances(slotData, start, end);
        for (const instance of instances) {
          // Exclude if booked
          if (instance.id && !bookedSlots[instance.id]) {
            filteredSlots.push(instance);
          }
        }
        if (instances.length > 0) {
          this.logger.debug(
            `Generated ${instances.length} instances from RECURRING template (dayOfWeek: ${slot.dayOfWeek})`
          );
        }
      }
    }

    this.logger.debug(`Filtered result: ${filteredSlots.length} slots`);
    return filteredSlots;
  }
  /**
   * Get all booked slots for a provider in a date range
   */
  private async getBookedSlots(providerId: string, startDate: Date, endDate: Date): Promise<{ [key: string]: boolean }> {
    this.logger.debug(`Checking booked slots for provider ${providerId} from ${startDate.toISOString()} to ${endDate.toISOString()}`);

    // Get all bookings and booked availabilities in parallel
    const [bookings, bookedAvailabilities] = await Promise.all([
      this.bookingModel.find({
        providerId,
        startTime: { $gte: startDate, $lte: endDate },
        status: { $ne: 'cancelled' }
      }).select('availabilityId startTime serialKey').lean(),
      
      this.availabilityModel.find({
        providerId,
        isBooked: true,
        $or: [
          { date: { $gte: startDate, $lte: endDate } },
          { type: AvailabilityType.RECURRING }
        ]
      }).select('_id type dayOfWeek startTime').lean()
    ]);

    this.logger.debug(`Found ${bookings.length} bookings and ${bookedAvailabilities.length} booked availabilities`);

    const bookedSlots: { [key: string]: boolean } = {};
    
    // Process bookings
    bookings.forEach(booking => {
      if (booking.availabilityId) {
        // For one-off slots
        bookedSlots[booking.availabilityId] = true;
        
        // For recurring slots, also mark the date-specific instance
        if (booking.startTime && booking.serialKey) {
          const dateKey = `${booking.availabilityId}_${booking.startTime.toISOString().split('T')[0]}`;
          bookedSlots[dateKey] = true;
        }
      }
    });
    
    // Process booked availabilities
    bookedAvailabilities.forEach(availability => {
      bookedSlots[availability._id.toString()] = true;
    });

    return bookedSlots;
  }

  /**
   * Generate specific instances from a recurring template for a date range
   */
  private generateRecurringInstances(
    template: AvailabilityData,
    startDate: Date,
    endDate: Date,
  ): IAvailabilityBase[] {
    const instances: IAvailabilityBase[] = [];
    const current = new Date(startDate);
    
    // Calculate days until first match of dayOfWeek
    const daysUntilFirst = (template.dayOfWeek! - current.getDay() + 7) % 7;
    current.setDate(current.getDate() + daysUntilFirst);
    
    // Now we're at first matching day, generate instances weekly
    while (current <= endDate) {
      // Only create instance if we haven't passed end date
      if (current <= endDate) {
        const instance = this.createInstanceFromTemplate(template, new Date(current));
        instances.push(instance);
        
        this.logger.debug(`Generated instance for template ${template._id}:
          date: ${current.toISOString()}
          dayOfWeek: ${current.getDay()}
          startTime: ${instance.startTime}
          endTime: ${instance.endTime}`
        );
      }
      
      // Jump to next week
      current.setDate(current.getDate() + 7);
    }
    
    return instances;
  }

  /**
   * Create a specific instance from a recurring template for a given date
   */
  private createInstanceFromTemplate(
    template: AvailabilityData,
    date: Date,
  ): IAvailabilityBase {
    // Get the time components from the template
    const templateStart = new Date(template.startTime);
    const templateEnd = new Date(template.endTime);
    
    // Create new date-times for the specific date
    const instanceStart = new Date(date);
    instanceStart.setHours(
      templateStart.getHours(),
      templateStart.getMinutes(),
      templateStart.getSeconds(),
      0
    );
    
    const instanceEnd = new Date(date);
    instanceEnd.setHours(
      templateEnd.getHours(),
      templateEnd.getMinutes(),
      templateEnd.getSeconds(),
      0
    );
    
    // Create the instance with the same properties as the template
    // but with specific date and times
    const instance: IAvailabilityBase = {
      id: `${template._id.toString()}_${date.toISOString().split('T')[0]}`, // Unique ID for this instance
      providerId: template.providerId, // Preserve provider ID
      type: AvailabilityType.ONE_OFF, // Instances are treated as one-off
      status: template.status,
      maxBookings: template.maxBookings,
      date: new Date(date),
      startTime: instanceStart,
      endTime: instanceEnd,
      duration: template.duration, // Preserve duration
      isBooked: false, // New instances are not booked
      dayOfWeek: undefined, // Remove dayOfWeek from instances
      isTemplate: false,
      isInstantiated: true,
      templateId: template._id.toString(),
      createdAt: template.createdAt,
      updatedAt: template.updatedAt
    };
    
    return instance;
  }

  /**
   * Clear cache for a provider
   */
  async clearProviderCache(providerId: string): Promise<void> {
    await this.cacheService.del(`availability:${providerId}`);
  }

  /**
   * Set cache for idempotency key
   */
  async setIdempotencyCache(key: string, data: any, ttlMinutes = 10): Promise<void> {
    const cacheKey = `idem:availability:${key}`;
    await this.cacheService.set(cacheKey, data, ttlMinutes * 60);
  }

  /**
   * Get cached idempotency result
   */
  async getIdempotencyCache<T>(key: string): Promise<T | null> {
    const cacheKey = `idem:availability:${key}`;
    const result = await this.cacheService.get<T>(cacheKey);
    return result ?? null;
  }
}
