import { Injectable, Logger, Inject } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Booking, BookingDocument, BookingStatus } from '../booking/booking.schema';
import { Availability, AvailabilityDocument } from '../availability/availability.schema';
import { CachingService } from '../../core/cache/caching.service';
import { AnalyticsGateway } from './analytics.gateway';

export interface AnalyticsMetrics {
  totalBookings: number;
  revenue: number;
  cancellations: number;
  occupancyRate: number;
}

export interface TimeSeriesDataPoint {
  date: Date;
  amount: number;
}

export interface OccupancyDataPoint {
  date: Date;
  rate: number;
}

export interface BookingTrendDataPoint {
  date: Date;
  count: number;
}

export interface AnalyticsData {
  metrics: AnalyticsMetrics;
  revenueData: {
    daily: TimeSeriesDataPoint[];
    weekly: TimeSeriesDataPoint[];
    monthly: TimeSeriesDataPoint[];
  };
  occupancyData: {
    daily: OccupancyDataPoint[];
    weekly: OccupancyDataPoint[];
    monthly: OccupancyDataPoint[];
  };
  bookingTrends: BookingTrendDataPoint[];
}

@Injectable()
export class AnalyticsService {
  private readonly logger = new Logger(AnalyticsService.name);

  constructor(
    @InjectModel(Booking.name) private readonly bookingModel: Model<BookingDocument>,
    @InjectModel(Availability.name) private readonly availabilityModel: Model<AvailabilityDocument>,
    @Inject(CachingService) private readonly cachingService: CachingService,
    private readonly analyticsGateway: AnalyticsGateway,
  ) {}

  async getAnalyticsData(providerId: string, startDate: Date, endDate: Date): Promise<AnalyticsData> {
    const cacheKey = `analytics:${providerId}:${startDate.toISOString()}:${endDate.toISOString()}`;
    
    // Try to get data from cache first
    const cachedData = await this.cachingService.get<AnalyticsData>(cacheKey);
    if (cachedData) {
      this.logger.log('üìä [AnalyticsService] Cache HIT for analytics data', { providerId, cacheKey });
      return cachedData;
    }
    
    this.logger.log('üìä [AnalyticsService] Cache MISS - Getting analytics data from database', { providerId, startDate, endDate });
    
    // Get metrics
    const metrics = await this.getMetrics(providerId, startDate, endDate);
    this.logger.log('üìà [AnalyticsService] Metrics retrieved', { providerId, metrics });
    
    // Get revenue data
    const revenueData = await this.getRevenueData(providerId, startDate, endDate);
    this.logger.log('üí∞ [AnalyticsService] Revenue data retrieved', { 
      providerId, 
      dailyCount: revenueData.daily.length,
      weeklyCount: revenueData.weekly.length,
      monthlyCount: revenueData.monthly.length
    });
    
    // Get occupancy data
    const occupancyData = await this.getOccupancyData(providerId, startDate, endDate);
    this.logger.log('üè† [AnalyticsService] Occupancy data retrieved', { 
      providerId, 
      dailyCount: occupancyData.daily.length,
      weeklyCount: occupancyData.weekly.length,
      monthlyCount: occupancyData.monthly.length
    });
    
    // Get booking trends
    const bookingTrends = await this.getBookingTrends(providerId, startDate, endDate);
    this.logger.log('üìã [AnalyticsService] Booking trends retrieved', { providerId, count: bookingTrends.length });
    
    const result: AnalyticsData = {
      metrics,
      revenueData,
      occupancyData,
      bookingTrends,
    };
    
    // Cache the result for 5 minutes (300 seconds)
    await this.cachingService.set(cacheKey, result, 300);

    this.logger.log('‚úÖ [AnalyticsService] Analytics data compilation complete and cached', { 
      providerId, 
      totalDataSize: JSON.stringify(result).length,
      cacheKey
    });

    // Emit update to clients subscribed to this provider
    this.analyticsGateway.emitAnalyticsUpdate(providerId, result);

    return result;
  }

  private async getMetrics(providerId: string, startDate: Date, endDate: Date): Promise<AnalyticsMetrics> {
    // Optimize by running all queries in parallel
    const [totalBookings, revenue, cancellations, occupancyRate] = await Promise.all([
      this.bookingModel.countDocuments({
        providerId,
        createdAt: { $gte: startDate, $lte: endDate },
      }),
      this.computeRevenue(providerId, startDate, endDate),
      this.bookingModel.countDocuments({
        providerId,
        status: BookingStatus.CANCELLED,
        createdAt: { $gte: startDate, $lte: endDate },
      }),
      this.computeOccupancyRate(providerId, startDate, endDate),
    ]);

    return {
      totalBookings,
      revenue,
      cancellations,
      occupancyRate,
    };
  }

  private async getRevenueData(providerId: string, startDate: Date, endDate: Date) {
    // Fetch all bookings once and reuse for all aggregations
    const bookings = await this.bookingModel.find({
      providerId,
      status: { $in: [BookingStatus.CONFIRMED, BookingStatus.COMPLETED] },
      startTime: { $gte: startDate, $lte: endDate },
    }).lean();

    // Daily revenue data
    const dailyData = this.calculateDailyRevenue(bookings);
    
    // Weekly revenue data
    const weeklyData = this.calculateWeeklyRevenue(bookings);
    
    // Monthly revenue data
    const monthlyData = this.calculateMonthlyRevenue(bookings);
    
    return {
      daily: dailyData,
      weekly: weeklyData,
      monthly: monthlyData,
    };
  }

  private calculateDailyRevenue(bookings: any[]): TimeSeriesDataPoint[] {
    // Group by day and calculate revenue
    const dailyMap: { [key: string]: number } = {};
    
    bookings.forEach(booking => {
      const dateKey = new Date(booking.startTime).toDateString();
      // For now, we'll use a placeholder revenue calculation
      // In a real implementation, this would be based on actual pricing
      const revenue = 50; // Placeholder value
      dailyMap[dateKey] = (dailyMap[dateKey] || 0) + revenue;
    });

    // Convert to array format
    return Object.entries(dailyMap).map(([dateStr, amount]) => ({
      date: new Date(dateStr),
      amount,
    }));
  }

  private calculateWeeklyRevenue(bookings: any[]): TimeSeriesDataPoint[] {
    // Group by week and calculate revenue
    const weeklyMap: { [key: string]: number } = {};
    
    bookings.forEach(booking => {
      const bookingDate = new Date(booking.startTime);
      // Get the start of the week (Sunday)
      const weekStart = new Date(bookingDate);
      weekStart.setDate(bookingDate.getDate() - bookingDate.getDay());
      weekStart.setHours(0, 0, 0, 0);
      
      const weekKey = weekStart.toDateString();
      // For now, we'll use a placeholder revenue calculation
      const revenue = 50; // Placeholder value
      weeklyMap[weekKey] = (weeklyMap[weekKey] || 0) + revenue;
    });

    // Convert to array format
    return Object.entries(weeklyMap).map(([dateStr, amount]) => ({
      date: new Date(dateStr),
      amount,
    }));
  }

  private calculateMonthlyRevenue(bookings: any[]): TimeSeriesDataPoint[] {
    // Group by month and calculate revenue
    const monthlyMap: { [key: string]: number } = {};
    
    bookings.forEach(booking => {
      const bookingDate = new Date(booking.startTime);
      // Get the start of the month
      const monthStart = new Date(bookingDate.getFullYear(), bookingDate.getMonth(), 1);
      const monthKey = monthStart.toDateString();
      // For now, we'll use a placeholder revenue calculation
      const revenue = 50; // Placeholder value
      monthlyMap[monthKey] = (monthlyMap[monthKey] || 0) + revenue;
    });

    // Convert to array format
    return Object.entries(monthlyMap).map(([dateStr, amount]) => ({
      date: new Date(dateStr),
      amount,
    }));
  }

  private async getOccupancyData(providerId: string, startDate: Date, endDate: Date) {
    // Fetch all availability data once for the date range
    const allAvailability = await this.availabilityModel.find({
      providerId,
      startTime: { $gte: startDate, $lte: endDate },
    }).lean();

    // Daily occupancy data
    const dailyData = this.calculateDailyOccupancy(allAvailability, startDate, endDate);
    
    // Weekly occupancy data
    const weeklyData = this.calculateWeeklyOccupancy(allAvailability, startDate, endDate);
    
    // Monthly occupancy data
    const monthlyData = this.calculateMonthlyOccupancy(allAvailability, startDate, endDate);
    
    return {
      daily: dailyData,
      weekly: weeklyData,
      monthly: monthlyData,
    };
  }

  private calculateDailyOccupancy(allAvailability: any[], startDate: Date, endDate: Date): OccupancyDataPoint[] {
    const occupancyData: OccupancyDataPoint[] = [];
    const currentDate = new Date(startDate);
    
    while (currentDate <= endDate) {
      const nextDay = new Date(currentDate);
      nextDay.setDate(currentDate.getDate() + 1);
      
      // Filter availability for the current day
      const dayAvailability = allAvailability.filter(slot => 
        slot.startTime >= currentDate && slot.startTime < nextDay
      );
      
      const totalSlots = dayAvailability.length;
      const bookedSlots = dayAvailability.filter(slot => slot.isBooked).length;
      const rate = totalSlots > 0 ? Math.round((bookedSlots / totalSlots) * 100) : 0;
      
      occupancyData.push({
        date: new Date(currentDate),
        rate,
      });
      
      currentDate.setDate(currentDate.getDate() + 1);
    }
    
    return occupancyData;
  }

  private calculateWeeklyOccupancy(allAvailability: any[], startDate: Date, endDate: Date): OccupancyDataPoint[] {
    const occupancyData: OccupancyDataPoint[] = [];
    const currentDate = new Date(startDate);
    
    // Adjust to start of week (Sunday)
    currentDate.setDate(currentDate.getDate() - currentDate.getDay());
    
    while (currentDate <= endDate) {
      const weekEnd = new Date(currentDate);
      weekEnd.setDate(currentDate.getDate() + 7);
      
      // Filter availability for the current week
      const weekAvailability = allAvailability.filter(slot => 
        slot.startTime >= currentDate && slot.startTime < weekEnd
      );
      
      const totalSlots = weekAvailability.length;
      const bookedSlots = weekAvailability.filter(slot => slot.isBooked).length;
      const rate = totalSlots > 0 ? Math.round((bookedSlots / totalSlots) * 100) : 0;
      
      occupancyData.push({
        date: new Date(currentDate),
        rate,
      });
      
      currentDate.setDate(currentDate.getDate() + 7);
    }
    
    return occupancyData;
  }

  private calculateMonthlyOccupancy(allAvailability: any[], startDate: Date, endDate: Date): OccupancyDataPoint[] {
    const occupancyData: OccupancyDataPoint[] = [];
    const currentDate = new Date(startDate);
    
    // Adjust to start of month
    currentDate.setDate(1);
    
    while (currentDate <= endDate) {
      const monthEnd = new Date(currentDate);
      monthEnd.setMonth(currentDate.getMonth() + 1);
      
      // Filter availability for the current month
      const monthAvailability = allAvailability.filter(slot => 
        slot.startTime >= currentDate && slot.startTime < monthEnd
      );
      
      const totalSlots = monthAvailability.length;
      const bookedSlots = monthAvailability.filter(slot => slot.isBooked).length;
      const rate = totalSlots > 0 ? Math.round((bookedSlots / totalSlots) * 100) : 0;
      
      occupancyData.push({
        date: new Date(currentDate),
        rate,
      });
      
      currentDate.setMonth(currentDate.getMonth() + 1);
    }
    
    return occupancyData;
  }

  private async getBookingTrends(providerId: string, startDate: Date, endDate: Date): Promise<BookingTrendDataPoint[]> {
    // Fetch all bookings once for the date range
    const bookings = await this.bookingModel.find({
      providerId,
      createdAt: { $gte: startDate, $lte: endDate },
    }).lean();

    // Group by day and count bookings
    const dailyMap: { [key: string]: number } = {};
    
    bookings.forEach(booking => {
      const dateKey = new Date(booking.createdAt).toDateString();
      dailyMap[dateKey] = (dailyMap[dateKey] || 0) + 1;
    });

    // Convert to array format
    return Object.entries(dailyMap).map(([dateStr, count]) => ({
      date: new Date(dateStr),
      count,
    }));
  }

  private async computeRevenue(providerId: string, startDate: Date, endDate: Date): Promise<number> {
    // For now, we'll use a placeholder revenue calculation
    // In a real implementation, this would be based on actual pricing
    const bookingCount = await this.bookingModel.countDocuments({
      providerId,
      status: { $in: [BookingStatus.CONFIRMED, BookingStatus.COMPLETED] },
      startTime: { $gte: startDate, $lte: endDate },
    });
    
    // Placeholder: 50 units per booking
    return bookingCount * 50;
  }

  private async computeOccupancyRate(providerId: string, startDate: Date, endDate: Date): Promise<number> {
    const [totalSlots, bookedSlots] = await Promise.all([
      this.availabilityModel.countDocuments({
        providerId,
        startTime: { $gte: startDate, $lte: endDate },
      }),
      this.availabilityModel.countDocuments({
        providerId,
        startTime: { $gte: startDate, $lte: endDate },
        isBooked: true,
      }),
    ]);
    
    if (totalSlots === 0) return 0;
    return Math.round((bookedSlots / totalSlots) * 100);
  }
}