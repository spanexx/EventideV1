import { Injectable } from '@angular/core';
import { Store } from '@ngrx/store';
import { AvailabilityService } from '../../../dashboard/services/availability.service';
import { Availability } from '../../../dashboard/models/availability.models';
import * as AvailabilityActions from '../../../dashboard/store-availability/actions/availability.actions';
import { AIToolResponse } from './ai-tool-definitions';

@Injectable({
  providedIn: 'root'
})
export class AIToolAvailabilityService {

  constructor(
    private availabilityService: AvailabilityService,
    private store: Store
  ) {}

  async createAvailabilitySlot(params: any, userId: string): Promise<AIToolResponse> {
    console.log('[AIToolAvailabilityService] createAvailabilitySlot called with params:', params);
    
    const { date, startTime, endTime, duration, type = 'one_off', dayOfWeek } = params;
    
    const startDateTime = new Date(`${date}T${startTime}`);
    const endDateTime = new Date(`${date}T${endTime}`);
    
    const availability: Availability = {
      id: '', // Will be generated by backend
      providerId: userId,
      startTime: startDateTime,
      endTime: endDateTime,
      duration: duration || this.calculateDuration(startDateTime, endDateTime),
      isBooked: false,
      type: type as 'one_off' | 'recurring',
      date: new Date(date),
      ...(dayOfWeek !== undefined && { dayOfWeek })
    };

    console.log('[AIToolAvailabilityService] Creating availability:', availability);

    try {
      const result = await this.availabilityService.createAIOptimizedAvailability(availability).toPromise();
      console.log('[AIToolAvailabilityService] Availability creation result:', result);
      
      // Dispatch store action to update UI
      this.store.dispatch(AvailabilityActions.createAvailabilitySuccess({ availability: result!.data }));
      
      return {
        success: true,
        data: result!.data,
        message: `Successfully created availability slot on ${date} from ${startTime} to ${endTime}. ${result!.aiAnalysis?.suggestions?.join(' ') || ''}`
      };
    } catch (error: any) {
      console.error('[AIToolAvailabilityService] Availability creation failed:', error);
      
      return {
        success: false,
        error: error.message,
        message: `Failed to create availability slot: ${error.message}`
      };
    }
  }

  async createBulkAvailability(params: any, userId: string): Promise<AIToolResponse> {
    const { pattern, startDate, endDate, startTime, endTime, duration, daysOfWeek, breakTime } = params;
    
    // Validate input for weekly pattern
    if (pattern === 'weekly' && (!daysOfWeek || daysOfWeek.length === 0)) {
      return {
        success: false,
        error: 'Missing daysOfWeek',
        message: 'Weekly recurring slots require specifying which days of the week.'
      };
    }

    // Convert day names to numbers if needed
    const dayNumbers = daysOfWeek?.map((day: string | number) => {
      if (typeof day === 'number') return day;
      const dayMap: Record<string, number> = {
        'sunday': 0, 'monday': 1, 'tuesday': 2, 'wednesday': 3,
        'thursday': 4, 'friday': 5, 'saturday': 6
      };
      return dayMap[day.toLowerCase()];
    });
    
    const bulkData = {
      providerId: userId,
      type: (pattern === 'weekly' ? 'recurring' : 'one_off') as 'one_off' | 'recurring',
      startDate: new Date(startDate),
      endDate: endDate ? new Date(endDate) : undefined,
      slots: this.generateBulkSlots({ ...params, daysOfWeek: dayNumbers }),
      skipConflicts: true
    };

    try {
      const result = await this.availabilityService.createBulkAIOptimized(bulkData).toPromise();
      
      // Update store
      result!.data.forEach(slot => {
        this.store.dispatch(AvailabilityActions.createAvailabilitySuccess({ availability: slot }));
      });
      
      const weekDayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      const dayList = Array.isArray(dayNumbers) ? dayNumbers.map((d: number) => weekDayNames[d]).join(', ') : '';

      return {
        success: true,
        data: result!.data,
        message: pattern === 'weekly' 
          ? `Successfully created recurring availability slots for ${dayList} from ${startTime} to ${endTime}. Efficiency score: ${result!.aiAnalysis.efficiencyScore}%`
          : `Successfully created ${result!.data.length} availability slots using ${pattern} pattern. Efficiency score: ${result!.aiAnalysis.efficiencyScore}%`
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message,
        message: `Failed to create bulk availability: ${error.message}`
      };
    }
  }

  async updateAvailabilitySlot(params: any, userId: string): Promise<AIToolResponse> {
    const { slotId, date, startTime, endTime, duration } = params;
    
    // Get current slot data first
    const currentData = await this.availabilityService.getAIEnhancedAvailability(
      userId, 
      new Date(), 
      false
    ).toPromise();
    
    const currentSlot = currentData!.data.find(slot => slot.id === slotId);
    if (!currentSlot) {
      return {
        success: false,
        error: 'Slot not found',
        message: `Availability slot with ID ${slotId} not found.`
      };
    }

    const updatedSlot: Availability = {
      ...currentSlot,
      ...(date && { date: new Date(date) }),
      ...(startTime && { startTime: new Date(`${date || currentSlot.date}T${startTime}`) }),
      ...(endTime && { endTime: new Date(`${date || currentSlot.date}T${endTime}`) }),
      ...(duration && { duration })
    };

    try {
      const result = await this.availabilityService.updateAIAnalyzed(updatedSlot).toPromise();
      
      // Dispatch store action to update UI
      this.store.dispatch(AvailabilityActions.updateAvailabilitySuccess({ availability: result!.data }));
      
      return {
        success: true,
        data: result!.data,
        message: `Successfully updated availability slot. ${result!.aiAnalysis?.impactAnalysis || ''}`
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message,
        message: `Failed to update availability slot: ${error.message}`
      };
    }
  }

  async deleteAvailabilitySlot(params: any): Promise<AIToolResponse> {
    const { slotId } = params;
    
    try {
      const result = await this.availabilityService.deleteAIAssessed(slotId).toPromise();
      
      // Dispatch store action to update UI
      this.store.dispatch(AvailabilityActions.deleteAvailabilitySuccess({ id: slotId }));
      
      return {
        success: true,
        data: { deletedId: slotId },
        message: `Successfully deleted availability slot. ${result!.aiAnalysis?.impactAssessment || ''} Risk level: ${result!.aiAnalysis?.riskLevel}`
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message,
        message: `Failed to delete availability slot: ${error.message}`
      };
    }
  }

  async deleteBulkAvailability(params: any, userId: string): Promise<AIToolResponse> {
    const { criteria, startDate, endDate, dayOfWeek, confirm } = params;
    
    if (!confirm && ['all', 'expired'].includes(criteria)) {
      return {
        success: false,
        error: 'Confirmation required',
        message: `Bulk deletion of '${criteria}' slots requires confirmation. Please confirm this destructive operation.`
      };
    }

    // Get availability data based on criteria
    const data = await this.availabilityService.getAIEnhancedAvailability(
      userId,
      startDate ? new Date(startDate) : new Date(),
      false
    ).toPromise();

    let slotsToDelete: Availability[] = [];
    
    switch (criteria) {
      case 'expired':
        slotsToDelete = data!.data.filter(slot => new Date(slot.endTime) < new Date());
        break;
      case 'unbooked':
        slotsToDelete = data!.data.filter(slot => !slot.isBooked);
        break;
      case 'date_range':
        if (startDate && endDate) {
          const start = new Date(startDate);
          const end = new Date(endDate);
          slotsToDelete = data!.data.filter(slot => {
            const slotDate = new Date(slot.date || slot.startTime);
            return slotDate >= start && slotDate <= end;
          });
        }
        break;
      case 'day_of_week':
        if (dayOfWeek !== undefined) {
          slotsToDelete = data!.data.filter(slot => {
            const slotDay = new Date(slot.date || slot.startTime).getDay();
            return slotDay === dayOfWeek;
          });
        }
        break;
      case 'all':
        slotsToDelete = data!.data;
        break;
    }

    if (slotsToDelete.length === 0) {
      return {
        success: true,
        data: { deletedCount: 0 },
        message: `No slots found matching criteria '${criteria}'.`
      };
    }

    try {
      // Delete slots one by one (could be optimized with bulk endpoint)
      const deletePromises = slotsToDelete.map(slot => 
        this.availabilityService.deleteAIAssessed(slot.id).toPromise()
      );
      
      await Promise.all(deletePromises);
      
      // Update store
      slotsToDelete.forEach(slot => {
        this.store.dispatch(AvailabilityActions.deleteAvailabilitySuccess({ id: slot.id }));
      });
      
      return {
        success: true,
        data: { deletedCount: slotsToDelete.length },
        message: `Successfully deleted ${slotsToDelete.length} availability slots matching criteria '${criteria}'.`
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message,
        message: `Failed to delete bulk availability: ${error.message}`
      };
    }
  }

  async getAvailabilityData(params: any, userId: string): Promise<AIToolResponse> {
    console.log('[AIToolAvailabilityService] getAvailabilityData called with params:', params);
    
    const { startDate, endDate, status = 'all', includeAnalysis = true } = params;
    
    const queryDate = startDate ? new Date(startDate) : new Date();
    console.log('[AIToolAvailabilityService] Query date:', queryDate);
    console.log('[AIToolAvailabilityService] User ID:', userId);
    
    if (!userId) {
      console.error('[AIToolAvailabilityService] No user ID available for data retrieval');
      return {
        success: false,
        error: 'No user context',
        message: 'Unable to retrieve availability data - no user context available.'
      };
    }
    
    try {
      console.log('[AIToolAvailabilityService] Calling getAIEnhancedAvailability...');
      
      const result = await this.availabilityService.getAIEnhancedAvailability(
        userId,
        queryDate,
        includeAnalysis
      ).toPromise();
      
      console.log('[AIToolAvailabilityService] Raw service result:', result);
      
      let filteredData = result!.data;
      console.log('[AIToolAvailabilityService] Initial data count:', filteredData.length);
      
      // Apply status filter
      if (status !== 'all') {
        console.log('[AIToolAvailabilityService] Applying status filter:', status);
        switch (status) {
          case 'available':
            filteredData = filteredData.filter(slot => !slot.isBooked);
            break;
          case 'booked':
            filteredData = filteredData.filter(slot => slot.isBooked);
            break;
          case 'expired':
            filteredData = filteredData.filter(slot => new Date(slot.endTime) < new Date());
            break;
        }
        console.log('[AIToolAvailabilityService] Filtered data count:', filteredData.length);
      }
      
      // Apply date range filter
      if (startDate && endDate) {
        console.log('[AIToolAvailabilityService] Applying date range filter:', { startDate, endDate });
        const start = new Date(startDate);
        const end = new Date(endDate);
        end.setHours(23, 59, 59, 999); // Include the entire end date
        filteredData = filteredData.filter(slot => {
          const slotDate = new Date(slot.date || slot.startTime);
          return slotDate >= start && slotDate <= end;
        });
        console.log('[AIToolAvailabilityService] Date filtered data count:', filteredData.length);
      } else if (startDate) {
        console.log('[AIToolAvailabilityService] Applying single date filter:', startDate);
        const targetDate = new Date(startDate);
        const nextDay = new Date(targetDate);
        nextDay.setDate(targetDate.getDate() + 1);
        filteredData = filteredData.filter(slot => {
          const slotDate = new Date(slot.date || slot.startTime);
          return slotDate >= targetDate && slotDate < nextDay;
        });
        console.log('[AIToolAvailabilityService] Single date filtered data count:', filteredData.length);
      }
      
      const responseData = {
        slots: filteredData,
        analysis: includeAnalysis ? result!.aiAnalysis : undefined,
        summary: {
          total: filteredData.length,
          available: filteredData.filter(s => !s.isBooked).length,
          booked: filteredData.filter(s => s.isBooked).length,
          expired: filteredData.filter(s => new Date(s.endTime) < new Date()).length
        }
      };
      
      console.log('[AIToolAvailabilityService] Final response data:', responseData);
      
      // Create message based on filtered results
      let message = `Found ${filteredData.length} availability slots.`;
      if (startDate && !endDate) {
        message = `Found ${filteredData.length} availability slots for ${new Date(startDate).toLocaleDateString()}.`;
      } else if (startDate && endDate) {
        message = `Found ${filteredData.length} availability slots from ${new Date(startDate).toLocaleDateString()} to ${new Date(endDate).toLocaleDateString()}.`;
      }
      
      if (result!.aiAnalysis?.summary) {
        message += ` ${result!.aiAnalysis.summary}`;
      }
      
      return {
        success: true,
        data: responseData,
        message
      };
    } catch (error: any) {
      console.error('[AIToolAvailabilityService] getAvailabilityData error:', error);
      
      return {
        success: false,
        error: error.message,
        message: `Failed to retrieve availability data: ${error.message}`
      };
    }
  }

  // Utility methods
  private calculateDuration(start: Date, end: Date): number {
    return Math.round((end.getTime() - start.getTime()) / (1000 * 60));
  }

  private generateBulkSlots(params: {
    pattern: string;
    startTime: string;
    endTime: string;
    duration?: number;
    daysOfWeek?: number[];
    breakTime?: number;
  }): Array<{
    dayOfWeek?: number;
    startTime: Date;
    endTime: Date;
    duration: number;
  }> {
    const { pattern, startTime, endTime, duration, daysOfWeek, breakTime = 0 } = params;

    // For recurring weekly slots
    if (pattern === 'weekly' && Array.isArray(daysOfWeek) && daysOfWeek.length > 0) {
      return daysOfWeek.map((dayOfWeek: number) => ({
        dayOfWeek,
        startTime: new Date(`2024-01-01T${startTime}`),
        endTime: new Date(`2024-01-01T${endTime}`),
        duration: duration || this.calculateDuration(
          new Date(`2024-01-01T${startTime}`),
          new Date(`2024-01-01T${endTime}`)
        )
      }));
    }

    // Default single slot configuration
    return [{
      startTime: new Date(`2024-01-01T${startTime}`),
      endTime: new Date(`2024-01-01T${endTime}`),
      duration: duration || this.calculateDuration(
        new Date(`2024-01-01T${startTime}`),
        new Date(`2024-01-01T${endTime}`)
      )
    }];
  }
}